<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="task-3.js"></script>
  <title>Дополнительные задания ООП</title>
</head>

<body>
  <h1>Задача № 1 this</h1>
  <p>К тебе пришел один владелец небольшого стартапа. Он предлагает сделать игру, которая поразит игровую индустрию. Ты,
    конечно же, соглашаешься, так как предложение звучит заманчиво.<br>
    <br>
    Суть игры состоит в том, что есть 2 замка (атакующий и защищающийся), которые враждуют между собой. Пользователь
    играет за атакующий замок. Царю атакующего замка необходимо каждый раз просчитывать возможности захвата враждующего
    замка. Когда возможность будет достаточно большой, то необходимо, не задумываясь, атаковать.<br>
    <br>
    В коде у тебя изначально есть 2 объекта attacker и defender, которые являются аналогиями замков, и у которых есть
    свойства, отвечающие за количество боевых единиц каждого типа.<br> Например, archer - это лучники, footSoldiers -
    пехотинцы, и т.д.:<br>
    <br>
    const attacker = {<br>
    archer: 30,<br>
    footSoldier: 55,<br>
    cavalry: 10,<br>
    artillery: 3, <br>
    }<br>
    <br>
    const defender = {<br>
    archer: 33,<br>
    footSoldier: 50,<br>
    cavalry: 40,<br>
    artillery: 10,<br>
    }<br>
    В объекте attacker тебе необходимо создать 3 функции:<br>
    <br>
    1. checkChancesToWin() - проверяет шансы атакующего замка захватить защищающийся замок. Данная функция принимает в
    себя<br>
    1 параметр defenderObject, который является объектом защищающегося замка - defender. Она должна сверять количество
    всех боевых единиц у обоих замков. Например, если у атакующего замка значение свойства archer больше, чем у
    защищающегося, то к шансам захвата необходимо прибавить 1 (изначально значение шансов должно быть равно нулю).
    Функция должна возвращать массив, в котором 1-й элемент - это шансы атакующего замка на захват, а 2-й - это значение
    максимального шанса на захват (количество ключей в объекте defenderObject). То есть, если у атакующего замка
    значения свойств archer и cavalry больше, чем у защищающегося, а другие значения свойств - меньше, то шансы на
    захват должны быть [2, 4] (образно шансы равны 2 из 4 либо 50%).<br>
    2. improveArmy() - прибавляет к каждому числовому значению объекта attacker по 5 единиц (обновляет свойства archer,
    footSoldier, cavalry, artillery). Данная функция не принимает никаких параметров.<br>
    3. attack() - принимает в себя 1 параметр - это объект защищающегося замка defender. Сначала эта функция проверяет,
    если шансы на захват (вызываем функцию checkChancesToWin()) меньше, чем 70% от максимальных шансов, то необходимо
    усилиться (вызвать функцию improveArmy()) и вывести сообщение через alert() “Наши шансы равны
    ourArmyChances/maximumChances}. Необходимо укрепление!” (ourArmyChances - шансы атакующего замка на захват,
    maximumChances - максимальный шанс на захват).<br> Иначе же требуется вывести сообщение в модальном окне “Мы
    усилились!
    Мы несомненно победим! Наши шансы высоки!”.<br>
    Пример результата работы функции attack():<br>
    <br>
    attacker.attack(defender); // Наши шансы равны 1/4. Необходимо укрепление!<br>
    attacker.attack(defender); // Наши шансы равны 2/4. Необходимо укрепление!<br>
    attacker.attack(defender); // Мы усилились! Мы несомненно победим! Наши шансы высоки!<br>
  </p>
  <h2>Задача № 2 -1 Class</h2>
  <p>В заданиях ранее ты реализовал логику для двух словарей, и они работают прекрасно. Но тут к тебе приходит старший
    разработчик и говорит, что необходимо добавить сокрытие.

    Ты конечно же соглашаешься со старшим разработчиком. Он посоветовал тебе сделать поля name и words приватными.
    Реализуй это с помощью знака решетки #.<br>
    <br>
    Усовершенствуй свое решение из задания #4.<br>
    <br>
    Теперь тебе необходимо добавить геттеры и сеттер в класс Dictionary, чтобы иметь доступ до приватных переменных.<br>

    Для #name создайте геттер mainName (через ключевое слово get) и сеттер mainName (через ключевое слово set).<br>

    Для #words создайте геттер allWords (через ключевое слово get).<br>
    <br>
    Также создай _addNewWord() - обычный метод класса, который будет добавлять новое слово в приватный объект #words
    (вместо сеттера). Он должен принимать:<br>
    <br>
    1- wordKey - слово (в данном случае это будет ключ, по которому добавляем в объект #words), тип данных строка.<br>
    2- wordObj - объект вида:<br>
    {<br>
    word: 'word',<br>
    description: 'description',<br>
    isDifficult: true // добавляется если слово сложное<br>
    }<br>
    Метод _addNewWord() должен только создавать новое слово в объекте #words без каких-либо проверок. Он реализуется без
    set, так как:<br>
    <br>
    1. set не может принимать в себя больше 1-го параметра<br>
    2. set в данном случае логичнее использовать для установки полностью нового значения, а не дополнения
    предыдущего<br>
    Метод _addNewWord() будет использоваться в методе add(). Мы их разделили, так как у них разная зона
    ответственности:<br>
    <br>
    1. _addNewWord() - отвечает за просто добавление слова в объект. Он используется только внутри классов в методе
    add().<br>
    2. add() - проверяет, есть ли уже данное слово в словаре, и, если слова нет, то вызывает метод _addNewWord(), чтобы
    добавить новое слово. Метод add() будет использоваться (вызываться) у экземпляра класса для безопасного добавления
    новых слов (пример ниже).<br>
    Тебе необходимо исправить логику для классов Dictionary и HardWordsDictionary<br>

    Итоговый код тестируй на данном примере:<br>

    const hardWordsDictionary = new HardWordsDictionary('Сложные слова');<br>
    <br>
    hardWordsDictionary.add('дилетант', 'Тот, кто занимается наукой или искусством
    без специальной подготовки, обладая только поверхностными знаниями.');<br>
    <br>
    hardWordsDictionary.add('неологизм', 'Новое слово или выражение, а также новое
    значение старого слова.');<br>
    <br>
    hardWordsDictionary.add('квант', 'Неделимая часть какой-либо величины в физике.');<br>
    <br>
    hardWordsDictionary.remove('неологизм');<br>
    <br>
    hardWordsDictionary.showAllWords();<br>
    <br>
    console.log(hardWordsDictionary.mainName); // Сложные слова<br>
    hardWordsDictionary.mainName = 'Новый Словарь';<br>
    console.log(hardWordsDictionary.mainName); // Новый Словарь<br>
    console.log(hardWordsDictionary.allWords); // выводит объект в котором есть слова
    // дилетант и квант
  </p>
  <h2>Задача № 3 -2 Class</h2>
  <p>Твой друг Артем является владельцем автосервиса. Сейчас все заявки на ремонт машин обрабатываются вручную, что,
    конечно же, не очень удобно. Поэтому Артем попросил тебя, как веб-разработчика, помочь в автоматизации данного
    процесса.<br>
    <br>
    Тебе необходимо создать класс CarService, в конструктор которого будут переданы 2 параметра:<br>
    <br>
    1. name - название автосервиса.<br>
    2. workingHours - время работы автосервиса. Объект с ключами from и till. from - время начала рабочего дня, till -
    время окончания рабочего дня. Значения времени записываются в формате “h:mm” (например, 9:00)<br>
    <br>
    Инициализируй данные параметры в конструкторе с помощью this. Также параметр workingHours является необязательным.
    Поэтому задай значение (тип данных object) по умолчанию. Данный объект должен называться DefaultWorkingHours и быть
    статическим (static). Если параметр workingHours не был передан, то подставь в this.workingHours значение из
    DefaultWorkingHours, которое равно:<br>
    <br>
    static DefaultWorkingHours = {<br>
    from: '9:00', <br>
    till: '20:00',<br>
    }<br>
    Добавь в класс метод под названием repairCar() , который будет чинить машину. Он должен принимать в себя 1 параметр
    carName - имя машины для ремонта (тип данных string).<br>
    <br>
    Если carName не был передан, то отобрази ошибку: “Вам необходимо указать название машины, чтобы ее отремонтировать”,
    в консоли через console.error(). На этом выполнение функции должно заканчиваться.<br>
    <br>
    Если же параметр carName был передан в repairCar(), то тебе необходимо сравнить текущее часы с временем работы
    автосервиса. Если текущее время (часы) не входит в диапазон работы автосервиса, то отобрази через alert() сообщение:
    “К сожалению, мы сейчас закрыты. Приходите завтра”. Иначе же выводи сообщение: “Сейчас отремонтируем вашу машину
    carName ! Ожидайте пожалуйста” (carName - параметр метода repairCar()).<br>
    <br>
    Примечание: при сравнении времени бери в учет только часы, на минуты не обращай внимание. Пусть минуты всегда будут
    строкой “00”. Для теста работоспособности класса CarService используй данный код:<br>
    <br>
    const carService = new CarService('RepairCarNow', { from: '8:00', till: '20:00' });<br>
    carService.repairCar('BMW');<br>
    Подсказка: для того чтобы извлечь из строки “8:00” значение часов, ты можешь использовать split(':'), получить
    первый элемент из полученного массива и преобразовать его к числу.
  </p>
</body>

</html>